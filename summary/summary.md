一、questions:
1、假设父类为Parent，子类为Children，如果子类继承了父类后，还想为子类添加新的方法，
   是不是只能 Children.prototype.xxx = function(){}这样逐个添加？ 是不是不能用字面量呢？

   因为我在写代码的过程中，子类继承了父类，想用字面量为子类添加新的方法【无论写不写constructor这个属性】，
   但是子类无法继承父类的方法。

   在经过测试之后
   1）、我发现如果是用了 inheritPrototype 这个方法的话，只能用 Children.prototype.xxx = function(){}
        这样逐个添加新的方法，因为只有这样才能继承父类的方法。
   2）、如果用了字面量的话，尽管上面用了 inheritPrototype 这个方法继承了父类，但是字面量会重写原型对象，
        而且，即使我在字面量上添加了 constructor 属性，设 constructor = Children ，也无法继承父类的方法。
        这感觉像是新建了另外一个 Children 一样，而这个新的 Children 还没来得及继承其 Parent 的属性以及方法

   老师，请问我这个想法正确吗？

2、
   if (board.pressedSpace) {
       // board.pressedSpace = false; // 如果加上这一句话就解决了以下问题，但我不知道为什么，请教一下老师
       plane.shoot();
   }
   如果按以上代码的话，按一下空格键，就会发射3颗子弹？正常来说，不是没按一下空格键就只会发射一枚子弹？


二、get:
1、canvas 的 drawImage 方法有个缺点，就是当图片还未加载完成时调用它将无效。
   因此，在使用 canvas 的 drawImage() 方法前，需要先预加载图片，当图片加载
   完了，再使用 drawImage() 绘制图片。

2、动画循环的三要素：更新需要绘制的对象、清除画布、在画布上重新绘制对象。三者缺一不可。
   对于不用“面向对象”对动画进行更新、清除、绘制，为了记录元素上一帧都干了些什么，需要在运动函数的外部建立变量将元素的相关信息（位置。。。）
   记录起来，但是运用了“面向对象”，就可以实时记录当前元素相应的变化值（例如：x、y坐标的变化）

3、如果 this.xxx 的值是要变化的，就不要用一个新的变量把它保存起来，这样的变化是无法遍历这个大对象的内部的。
   例如：this.currentLevel（当前的关卡数）

三、补充
1） 这是我第一次做游戏，也是第一次体验到做游戏的感觉，还挺不错。由于缺乏经验，所以第一次提交的作业并没有考虑性能。
    经过百度、google，现在也对canvas性能有了一定的理解。
所以我做了以下修改：
1、在第一次作业中，每new一个新对象，就会 new Image()，这是错误的。原因：每 new 一次就新建一个图片实例，从而浪费内存
   因此在加载完图片后，我将 CONFIG 里的图片（原来是路径），直接用 new Image()覆盖了，这就保证了每一张图片只需 new 一个图片实例。

2、第一次作业中，误认为每两帧动画间的交接直接将整个画布清除就好，这是个大大的错误！这会严重降低性能。
  正确的方法应该是 “dirty rectangle”，即：只对有改变（例如：位置改变了）的区域进行重绘，而不是全区域重绘。
  因此，我分别对敌人、飞机、子弹、分数进行了“脏区重绘”，不过当游戏结束（无论什么原因），我仍然是对全区域重绘
  【我觉得这个只需要重绘一次，因为它不像飞机、敌人，需要频繁地运动、频繁地更新、频繁地重绘】

3、使用了离屏canvas。
   感觉离屏canvas的原理有点像操作DOM一样，先在fragment上创建多个dom，再将fragment添加到所需元素上。
   因此，对敌人、飞机、子弹、分数的创建都用了离屏canvas

【老师，可以帮我看看我所做的以上修改吗？】

2）知道了四叉树，QuadTree可以大大减少需要测试碰撞的次数，从而提高游戏刷新性能，不过还没研究，打算把js的一些基础打扎实了，才去研究算法




